[복습]

2020.11.02

# return의 기능 : 값 반환의 의미, 메서드 실행 중단

#break : 가장 가까운 반복문을 빠져나감.

# continue : 해당 회차를 빠져나감.
# for 문 : break를 빠져나가서 증감식으로 들어감.
# while 문 : continue를 빠져나가서 조건식으로 들어감.

@ switch ~ case : == 연산, int, String, enum
break

@ while 문 ??

@ for 문 : 특정 코드들을 반복.
- for ( ) 적습니다.
- ( ) 소괄호 안에 초기화, 조건식, 증감식을 적습니다.
- ( ) 소괄호 옆에 중괄호 { } 를 적습니다.
- 중괄호 { } 안에 반복할 코드를 적습니다.

@ if 문 (상황에 따라 실행코드를 달리하고 싶을 때, ~면, ~라면, ~이면)
- 단순 if : ~면 ~해라.
- if else : ~면 ~해라, 그렇지 않으면 ~해라.
- 다중 if : ~면 ~해라, 그렇지 않고 ~면 ~해라, 그렇지 않으면 ~해라.

@ 연산자

/ : 정수형에서는 몫만 표현 가능.
0, 0, 0, 1, 1, 1, 2, 2, 2
-> n / 3

% : 나머지 연산자, 어떤 수가 배수인지 여부 확인 할 때
n % 3 == 0
0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3
-> n % 4(젤 큰 값 3+1)

a += b // a = a+b; // a 값은 변하지만 뒤에 있는 b의 값은 안 변함.
a -= b // a = a-b;
a *= b // a = a*b;
a /= b // a = a/b;
a %= b // a = a%b;

>, >=, <, <=, ==, != : boolean

&&, ||, !
&& : 연산에 참여하는 데이터가 모두 true 일 때만 true, 그렇지 않으면 false
|| : 연산에 참여하는 데이터가 모두 false 일 때만 false, 그렇지 않으면 true
! : 값 반전, true -> false, false -> true

++, -- : 1씩 증감
++a, --a : 즉시 증감해서 a에 대입
a++, a++ : 나중에 a를 만났을 때, 대입
int a = 10;
sysout(a++);  ==> 10
int a = 10;
sysout(++a);  ==> 11

조건연산자 (=삼항연산자)
type 변수명 = 조건식 ? 참일 때의 값 : 거짓일 때의 값;
type 변수명 = 조건식1? 참일 때의 값1 : 조건식2? 참일 때의 값2 : 조건1, 2가
모두 거짓일 때의 값;

# 참조자료형의 변수 (=객체, 인스턴스)가 갖고 있는 자원에 접근 하려면
객체명.

<클래스 VS 객체>
a. 객체 : 국어 사전에서 명사, 실체
객체 생성 공식 : 참조자료형 객체명(=변수명) = new 생성자 ( );
힙메모리에 저장 됨.
참조자료형으로 만들어 짐.
객체가 갖고 있는 자원에 접근 또는 사용할 때 :
객체명.변수명; / 객체명. 상수명; / 객체명. 메서드명;

b. 클래스 : 설계도의 의미.. class라는 키워드가 있어야 클래스
클래스는 단독으로 실행 안 됨. 객체를 만들어서 실행해야 함.
클래스의 구성 요소 : 멤버변수 / 상수 , 생성자, 메서드
객체 구성 요소를 표현하는 자료 : 멤버변수/ 상수
객체 생성법을 표현하는 자료 : 생성자
객체의 기능을 표현하는 자료 : 메서드

@ this : 객체 자기 자신 / 지역 변수와 멤버변수의 변수명이 같을 때, 컴파일러가
       지역변수를 우선적으로 인식함으로 구분을 둬야 함.
생성자의 첫 라인에 작성해야 하므로, 보통 메서드를 사용.
this ( ) : 해당 클래스의 생성자 호출
this (3);
this(new Dog( ));
this.a = a;

@ 생성자 : 객체 생성 시 값을 제공, 멤버변수 초기화 역할.
- 디폴트 생성자 : 파라미터가 없음
- 사용자 생성자 : 파라미터가 있음
생성자가 눈에 안 보인다 : 디폴트 생성자 존재
사용자 생성자 2개가 눈에 보인다 : 사용자 생성자만 2개 존재, 디폴트 생성자 X
동적인 객체를 만들고 싶으면 : 사용자 생성자
public  클래스명 ( ) {
}

@ 메서드 오버로딩(=오버로딩) : 같은 클래스, 메서드 이름이 같음.
파라미터의 자료형과 관련이 있음.
접근제한자x, 반환형x, 파라미터의 변수명x
1. 메서드 파라미터의 개수가 다르면 O
2. 메서드 파라미터의 자료형이 다르면 O
3. 메서드 파라미터의 자료형의 배치 순서가 다르면 O

@ 메서드 : 객체의 기능(=능력, 행위)을 표현
public 반환형 메서드명(자료형1 변수명1, 자료형2 변수명2){

	//return 자료형에 맞는 값; [반환형이 void가 아닐 경우]
}

- 무반환 무파람 : 메서드명 ( );
- 무반환 유파람 : set( ) , 메서드명 (자료형에 맞는 값1, 자료형에 맞는 값2 );
- 유반환 무파람 : get( ) , 반환형과 같은 자료형 변수명 = 메서드명 ( );
- 유반환 유파람 : 반환형과 같은 자료형 변수명 = 메서드명(자료형에 맞는 값1, 자료형에 맞는 값2);


 <지역변수 VS 멤버변수>
a. 지역변수 : 메서드나 생성자 안에서 선언된 변수
[스코프 : 선언된 순간부터 가장 가까운 중괄호 } 까지]
자료형 변수명; <- 변수 선언
자료형 변수명 = 자료형에 맞는 값; <- 선언과 초기화
변수명 = 자료형에 맞는 값; <- 대입 (대입을 위해서는 선언이 있어야 함)
멤버변수명 = 자료형에 맞는 값; <- 만약 생성자에 이런 코드가 있다면, 초기화.

b. 멤버변수 : 클래스의 필드에 선언된 변수
[스코프 : 해당 클래스 전체]
private : 해당 클래스에서만 접근 가능.
private 자료형 변수명;
초기화는 생성자 안에서 이루어진다.
객체의 구성 요소, 클래스의 구성 요소 역할.

@ 지역(local) 변수 : 유지보수 편하게 함.
메서드 안에서 중복되는 데이터는 변수 처리.
클래스 안에서 중복되는 코드는 메서드 처리.
프로젝트 안에서 중복되는 메서드, 변수, 상수는 상속 처리.
*변수 선언 공식 : 자료형 변수명 = 자료형에 맞는 값;

자료형 : 1. 기본자료형 : 
boolean, char, byte, short, int, long, float, double

2. 참조자료형 : 기본자료형이 아닌 자료형.
*참조자료형의 변수 선언 공식 : 참조자료형 변수명 = new 생성자( );
*new : 힙메모리에 저장공간을 할당하라는 의미
변수명 : 객체가 저장된 힙메모리의 주소값.

